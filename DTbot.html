<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dice Throne — Bot (sélecteur + statuts)</title>
  <style>
    :root{
      --bg:#0b0f17; --text:#e9eefb; --muted:#9aa7c0;
      --border:rgba(255,255,255,.09); --shadow:0 12px 30px rgba(0,0,0,.35);
      --acc:rgba(110,231,255,.18); --acc2:rgba(167,139,250,.18);
      --good:#34d399; --bad:#fb7185; --warn:#fbbf24;
      --r:16px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    body{ margin:0; color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, var(--acc), transparent 50%),
        radial-gradient(900px 600px at 110% 30%, var(--acc2), transparent 50%),
        var(--bg);
    }
    header{ max-width:1150px; margin:0 auto; padding:18px 16px 10px; }
    h1{ margin:0; font-size:18px; }
    .sub{ color:var(--muted); font-size:13px; margin-top:6px; line-height:1.35; }
    .wrap{ max-width:1150px; margin:0 auto; padding:0 16px 22px; }
    .grid{ display:grid; grid-template-columns: 1.12fr .88fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--border); border-radius:var(--r);
      box-shadow:var(--shadow); overflow:hidden;
    }
    .hd{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      padding:12px; border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    .hd h2{ margin:0; font-size:14px; letter-spacing:.2px; }
    .bd{ padding:12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .sp{ height:10px; }
    .pill{
      padding:6px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--border);
      color:var(--muted); font-size:12px;
    }
    .pill b{ color:var(--text); font-weight:800; }

    button{
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      transition: transform .04s ease, background .15s ease;
    }
    button:hover{ background: rgba(255,255,255,.09); }
    button:active{ transform: translateY(1px); }
    button.primary{ border-color: rgba(110,231,255,.35); background: rgba(110,231,255,.10); }
    button.good{ border-color: rgba(52,211,153,.35); background: rgba(52,211,153,.10); }
    button.bad{ border-color: rgba(251,113,133,.35); background: rgba(251,113,133,.10); }
    button.warn{ border-color: rgba(251,191,36,.35); background: rgba(251,191,36,.10); }
    button.small{ padding:8px 10px; border-radius:10px; font-size:13px; }

    textarea, select{
      background: rgba(0,0,0,.22);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      width:100%;
      box-sizing:border-box;
    }
    label{ color:var(--muted); font-size:12px; display:block; margin-bottom:6px; }

    .kpi{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .kpi{ grid-template-columns:1fr; } }
    .box{
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px;
    }
    .box .lbl{ color:var(--muted); font-size:12px; display:flex; justify-content:space-between; }
    .box .val{ font-size:22px; font-weight:900; margin-top:6px; }
    .box .ctl{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }

    .dice{ display:flex; gap:10px; flex-wrap:wrap; }
    .die{
      width:56px; height:56px; border-radius:14px;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(255,255,255,.06);
      border:1px solid var(--border);
      font-size:18px; font-weight:900;
      user-select:none;
      position:relative;
      line-height:1.05;
    }
    .die.locked{
      border-color: rgba(167,139,250,.55);
      background: rgba(167,139,250,.12);
    }
    .die .n{ font-size:12px; color:var(--muted); font-weight:900; margin-top:4px; }
    .die .mini{
      position:absolute; bottom:6px; right:8px;
      font-size:10px; color:var(--muted); font-weight:900;
    }

    .statusRow{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .status{
      display:flex; gap:8px; align-items:center;
      padding:8px 10px; border-radius:14px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      font-size:12px; color:var(--muted);
    }
    .status b{ color:var(--text); }
    .dot{
      width:10px; height:10px; border-radius:999px; display:inline-block;
      background: rgba(255,255,255,.25);
    }
    .dot.combo{ background: rgba(167,139,250,.9); }
    .dot.webbed{ background: rgba(110,231,255,.9); }
    .dot.invis{ background: rgba(251,113,133,.9); }

    .log{ max-height: 360px; overflow:auto; padding-right:4px; }
    .logItem{
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      border-radius:14px;
      padding:10px;
      margin-bottom:8px;
      font-size:13px;
      line-height:1.35;
    }
    .logItem time{ color:var(--muted); font-size:11px; display:block; margin-bottom:4px; }
    .tag{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      font-size:11px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      color:var(--muted);
      margin-right:6px;
    }
    .tag.bot{ color: rgba(167,139,250,.95); border-color: rgba(167,139,250,.25); }
    .tag.you{ color: rgba(110,231,255,.95); border-color: rgba(110,231,255,.25); }

    details{ border:1px solid var(--border); border-radius:14px; padding:10px; background: rgba(0,0,0,.18); }
    summary{ cursor:pointer; font-weight:900; }
    .muted{ color:var(--muted); font-size:12px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .warnTxt{ color: rgba(251,191,36,.95); }
  </style>
</head>

<body>
<header>
  <h1>Dice Throne — Bot (sélecteur + dégâts + statuts)</h1>
  <div class="sub">
    ✅ Spider-Man (Miles) est complet (attaques + Combo/Entoilé/Invisibilité).<br>
    ⚠️ Thor/Loki/Scarlet : sélecteur prêt, mais il me faut leurs plateaux/feuilles pour remplir les attaques (sinon je devine = faux).
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <section class="card">
      <div class="hd">
        <h2>Table</h2>
        <div class="row">
          <span class="pill">Tour: <b id="turnPill">1</b></span>
          <span class="pill">Actif: <b id="activePill">Toi</b></span>
        </div>
      </div>

      <div class="bd">
        <div class="row" style="justify-content:space-between;">
          <div style="min-width:260px; flex:1;">
            <label>Choisir le bot</label>
            <select id="botSelect">
              <option value="spiderman">Spider-Man (Miles Morales)</option>
              <option value="thor">Thor (à configurer)</option>
              <option value="loki">Loki (à configurer)</option>
              <option value="scarlet">Scarlet Witch (à configurer)</option>
            </select>
          </div>

          <div style="min-width:260px; flex:1;">
            <label>Rappel dés Miles</label>
            <div class="muted">
              1–3 = <b>THWIP</b> · 4–5 = <b>TOILE</b> · 6 = <b>ARAIGNÉE</b>
            </div>
          </div>
        </div>

        <div class="sp"></div>

        <div class="kpi">
          <div class="box">
            <div class="lbl"><span>Toi</span><span class="muted">PV / PC</span></div>
            <div class="val"><span id="youHp">50</span><span class="muted"> PV</span> · <span id="youCp">2</span><span class="muted"> PC</span></div>

            <div class="sp"></div>
            <div class="statusRow">
              <span class="status"><span class="dot webbed"></span> Entoilé: <b id="youWebbed">0</b></span>
              <span class="status"><span class="dot invis"></span> Invisibilité: <b id="youInvis">0</b></span>
            </div>

            <div class="ctl">
              <button class="small good" data-who="you" data-what="hp" data-d="1">+1 PV</button>
              <button class="small bad"  data-who="you" data-what="hp" data-d="-1">-1 PV</button>
              <button class="small good" data-who="you" data-what="cp" data-d="1">+1 PC</button>
              <button class="small bad"  data-who="you" data-what="cp" data-d="-1">-1 PC</button>

              <button class="small warn" id="youAddWebbed">+ Entoilé</button>
              <button class="small" id="youRemWebbed">- Entoilé</button>

              <button class="small warn" id="youAddInvis">+ Invis</button>
              <button class="small" id="youRemInvis">- Invis</button>
            </div>
          </div>

          <div class="box">
            <div class="lbl"><span>Bot</span><span class="muted">PV / PC</span></div>
            <div class="val"><span id="botHp">50</span><span class="muted"> PV</span> · <span id="botCp">2</span><span class="muted"> PC</span></div>

            <div class="sp"></div>
            <div class="statusRow">
              <span class="status"><span class="dot combo"></span> Combo: <b id="botCombo">0</b></span>
              <span class="status"><span class="dot invis"></span> Invisibilité: <b id="botInvis">0</b></span>
            </div>

            <div class="ctl">
              <button class="small good" data-who="bot" data-what="hp" data-d="1">+1 PV</button>
              <button class="small bad"  data-who="bot" data-what="hp" data-d="-1">-1 PV</button>
              <button class="small good" data-who="bot" data-what="cp" data-d="1">+1 PC</button>
              <button class="small bad"  data-who="bot" data-what="cp" data-d="-1">-1 PC</button>

              <button class="small warn" id="botAddCombo">+ Combo</button>
              <button class="small" id="botRemCombo">- Combo</button>

              <button class="small warn" id="botAddInvis">+ Invis</button>
              <button class="small" id="botRemInvis">- Invis</button>
            </div>
          </div>
        </div>

        <div class="sp"></div>

        <div class="box">
          <div class="lbl"><span>Dés (bot)</span><span class="muted">clic = lock (debug)</span></div>
          <div class="sp"></div>
          <div class="dice" id="diceRow"></div>

          <div class="sp"></div>
          <div class="row">
            <button class="ghost" id="endYourTurnBtn">Fin de ton tour → Bot</button>
            <button class="primary" id="botTurnBtn">Jouer le tour du Bot</button>
            <button class="bad" id="resetBtn">Reset</button>
          </div>

          <div class="sp"></div>
          <div class="muted">
            Ton tour = manuel (tu ajustes PV/PC/statuts). Le bot gère ses attaques + statuts automatiquement.
          </div>
        </div>

        <div class="sp"></div>

        <details>
          <summary>Attaques du bot (JSON) — utile pour Thor/Loki/Scarlet</summary>
          <div class="sp"></div>
          <div class="muted">
            Format : tableau d’objets. Exemple Miles ci-dessous.<br>
            Champs supportés : <span class="mono">name, req, type, damage, undefendable, effects</span>.<br>
            req = {THWIP:n, TOILE:n, ARAIGNEE:n} ou <span class="mono">{"STRAIGHT":4}</span> / <span class="mono">{"STRAIGHT":5}</span>.<br>
            effects possibles : <span class="mono">gainCombo, gainInvis, inflictWebbed, roll2DamageSum, draw1</span>
          </div>
          <div class="sp"></div>
          <label>Éditeur attaques (appliqué au bot sélectionné)</label>
          <textarea id="attacksJson" rows="14" class="mono"></textarea>
          <div class="sp"></div>
          <div class="row">
            <button class="small ghost" id="loadFromBotBtn">Charger depuis le bot</button>
            <button class="small good" id="applyAttacksBtn">Appliquer</button>
          </div>
          <div class="sp"></div>
          <div class="muted warnTxt">
            ⚠️ Pour Thor/Loki/Scarlet : colle leurs attaques ici (je peux te les préparer si tu m’envoies leurs plateaux).
          </div>
        </details>

      </div>
    </section>

    <aside class="card">
      <div class="hd">
        <h2>Journal</h2>
        <div class="row">
          <button class="small ghost" id="clearLogBtn">Vider</button>
        </div>
      </div>
      <div class="bd">
        <div class="log" id="log"></div>
      </div>
    </aside>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const nowStamp = () => {
    const d = new Date();
    const p = (x)=>String(x).padStart(2,"0");
    return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`;
  };
  const escapeHtml = (str) => String(str).replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[s]));

  // === Dice mapping for Miles (from your sheet) ===
  // 1-3 THWIP, 4-5 TOILE, 6 ARAIGNEE
  function faceOf(n){
    if(n <= 3) return "THWIP";
    if(n <= 5) return "TOILE";
    return "ARAIGNEE";
  }

  // === Bots database ===
  // NOTE: Only Miles is filled with real data from your images.
  // Thor/Loki/Scarlet are placeholders until you share their boards.
  const BOTS = {
    spiderman: {
      name: "Spider-Man (Miles Morales)",
      attacks: [
        // Allonge II: 3/4/5 THWIP => 5/6/7 damage; if 4 identical numbers => gain Combo
        { name:"Allonge II (3 THWIP)", req:{THWIP:3}, type:"attack", damage:5, undefendable:false, effects:{} },
        { name:"Allonge II (4 THWIP)", req:{THWIP:4}, type:"attack", damage:6, undefendable:false, effects:{ gainComboIf4Same:true } },
        { name:"Allonge II (5 THWIP)", req:{THWIP:5}, type:"attack", damage:7, undefendable:false, effects:{} },

        // C-C-C-Combo II: THWIP THWIP + ARAIGNEE ARAIGNEE => 6 dmg + Combo
        { name:"C-C-C-Combo II", req:{THWIP:2, ARAIGNEE:2}, type:"attack", damage:6, undefendable:false, effects:{ gainCombo:true } },

        // Jet de Toile: TOILE TOILE + ARAIGNEE => gain Invis + inflict Entoilé
        { name:"Jet de Toile", req:{TOILE:2, ARAIGNEE:1}, type:"utility", damage:0, undefendable:false, effects:{ gainInvis:true, inflictWebbed:true } },

        // Grimpe-Murs: THWIP THWIP + TOILE TOILE TOILE => gain Invis + 7
        { name:"Grimpe-Murs", req:{THWIP:2, TOILE:3}, type:"attack", damage:7, undefendable:false, effects:{ gainInvis:true } },

        // Réflexes d’Araignée: THWIP + TOILE TOILE + ARAIGNEE => roll 2 dice, deal sum; if sum <= 5 gain Combo
        { name:"Réflexes d’Araignée", req:{THWIP:1, TOILE:2, ARAIGNEE:1}, type:"attack", damage:0, undefendable:false, effects:{ roll2DamageSum:true, gainComboIfSumLE:5 } },

        // Piège II: (small straight => 6 + webbed) / (large straight => draw1 + 9 + webbed)
        // Requirements icons are blurred on the photo, so we implement as classic straight-length on numbers:
        { name:"Piège II (Petite suite)", req:{STRAIGHT:4}, type:"attack", damage:6, undefendable:false, effects:{ inflictWebbed:true } },
        { name:"Piège II (Grande suite)", req:{STRAIGHT:5}, type:"attack", damage:9, undefendable:false, effects:{ inflictWebbed:true, draw1:true } },

        // Allonge Venimeuse II: 4 spiders => gain Invis + 8 undefendable
        { name:"Allonge Venimeuse II", req:{ARAIGNEE:4}, type:"attack", damage:8, undefendable:true, effects:{ gainInvis:true } },

        // Enchaînement de Combos: (requirement not fully visible; effect visible: gain Combo + 2 undefendable)
        // We implement as 3 spiders (very plausible on Miles dice economy).
        { name:"Enchaînement de Combos", req:{ARAIGNEE:3}, type:"attack", damage:2, undefendable:true, effects:{ gainCombo:true } },

        // ULT: 5 spiders => gain Invis + inflict webbed + then 13 dmg
        { name:"Onde de choc venimeuse (ULT)", req:{ARAIGNEE:5}, type:"attack", damage:13, undefendable:false, effects:{ gainInvis:true, inflictWebbed:true } },
      ]
    },

    thor:   { name:"Thor",          attacks: [] },
    loki:   { name:"Loki",          attacks: [] },
    scarlet:{ name:"Scarlet Witch", attacks: [] },
  };

  // === State ===
  const state = {
    turn: 1,
    active: "you", // "you" | "bot"
    you: { hp: 50, cp: 2, hpMax: 50, webbed:0, invis:0 },
    bot: { hp: 50, cp: 2, hpMax: 50, combo:0, invis:0 },
    botDice: Array.from({length:5}, ()=>({value:1, locked:false})),
    botKey: "spiderman",
    attacks: structuredClone(BOTS.spiderman.attacks),
    log: []
  };

  // === Log ===
  function addLog(who, text){
    state.log.push({ t: nowStamp(), who, text });
    renderLog();
  }

  // === Dice ===
  function rollUnlockedDice(){
    for(const d of state.botDice){
      if(!d.locked){
        d.value = 1 + Math.floor(Math.random()*6);
      }
    }
  }
  function diceValues(){ return state.botDice.map(d=>d.value); }
  function diceFaces(){ return state.botDice.map(d=>faceOf(d.value)); }

  function countsFaces(faces){
    const c = {THWIP:0, TOILE:0, ARAIGNEE:0};
    for(const f of faces) c[f] = (c[f]||0)+1;
    return c;
  }

  function maxSameNumber(vals){
    const m = new Map();
    for(const v of vals) m.set(v, (m.get(v)||0)+1);
    return Math.max(...m.values());
  }

  function isStraightLen(vals, len){
    const uniq = [...new Set(vals)].sort((a,b)=>a-b);
    let best = 1, cur = 1;
    for(let i=1;i<uniq.length;i++){
      if(uniq[i] === uniq[i-1]+1){ cur++; best = Math.max(best, cur); }
      else cur = 1;
    }
    return best >= len;
  }

  function matchesReq(req, vals, faces){
    if(req.STRAIGHT){
      return isStraightLen(vals, req.STRAIGHT|0);
    }
    const c = countsFaces(faces);
    for(const k of ["THWIP","TOILE","ARAIGNEE"]){
      const need = req[k] || 0;
      if(c[k] < need) return false;
    }
    return true;
  }

  // === Bot choice / scoring ===
  function attackScore(a){
    // simple priority: higher damage + prefer undefendable + prefer inflicting status + ult bonus
    let s = (a.damage||0);
    if(a.undefendable) s += 1.5;
    if(a.effects?.inflictWebbed) s += 1.0;
    if(a.effects?.gainInvis) s += 0.4;
    if(a.effects?.gainCombo) s += 0.6;
    if(/ULT/i.test(a.name)) s += 2.0;
    if(a.effects?.roll2DamageSum) s += 0.8;
    return s;
  }

  function bestPlayableAttack(vals, faces){
    let best = null;
    for(const a of state.attacks){
      if(matchesReq(a.req, vals, faces)){
        const s = attackScore(a);
        if(!best || s > best.s) best = {a, s};
      }
    }
    return best?.a || null;
  }

  // Lock policy (very simple):
  // - if aiming for spiders: lock spiders
  // - if aiming for thwip count: lock thwips
  // - if aiming for straight: lock unique numbers
  function chooseTarget(vals, faces){
    // pick the best "potential" attack based on closeness
    const c = countsFaces(faces);
    let best = null;

    for(const a of state.attacks){
      let closeness = 0.2;
      if(a.req.STRAIGHT){
        const need = a.req.STRAIGHT|0;
        const uniq = new Set(vals).size;
        closeness = clamp(uniq/need, 0, 1);
      } else {
        const needT = a.req.THWIP||0, needW=a.req.TOILE||0, needS=a.req.ARAIGNEE||0;
        const part =
          (needT? clamp(c.THWIP/needT,0,1):1) *
          (needW? clamp(c.TOILE/needW,0,1):1) *
          (needS? clamp(c.ARAIGNEE/needS,0,1):1);
        closeness = clamp(part,0,1);
      }
      const score = attackScore(a) * (0.35 + 0.65*closeness);
      if(!best || score > best.score) best = {a, score};
    }
    return best?.a || null;
  }

  function lockForTarget(target, vals, faces){
    state.botDice.forEach(d => d.locked = false);
    if(!target) return;

    if(target.req.STRAIGHT){
      // lock unique values (keep 1 per unique)
      const seen = new Set();
      for(const d of state.botDice){
        if(!seen.has(d.value)){
          d.locked = true;
          seen.add(d.value);
        }
      }
      return;
    }

    // lock the face type that is most "important" for target (largest deficit)
    const c = countsFaces(faces);
    const deficits = [
      {k:"ARAIGNEE", need: target.req.ARAIGNEE||0, have:c.ARAIGNEE},
      {k:"TOILE",    need: target.req.TOILE||0,    have:c.TOILE},
      {k:"THWIP",    need: target.req.THWIP||0,    have:c.THWIP},
    ].map(x => ({...x, def: Math.max(0, x.need-x.have)}));

    deficits.sort((a,b)=>b.def-a.def);

    const focus = deficits[0].def > 0 ? deficits[0].k : (
      (target.req.ARAIGNEE||0)>0 ? "ARAIGNEE" :
      (target.req.TOILE||0)>0 ? "TOILE" : "THWIP"
    );

    state.botDice.forEach(d => {
      if(faceOf(d.value) === focus) d.locked = true;
    });
  }

  // === Status rules (from your Miles status card) ===
  // Combo (bot): spend to do an additional Offensive Roll Phase (max once per turn)
  // Entoilé (on you): 
  //   - If you are attacked with NORMAL dice damage next time: that damage becomes UNDEFENDABLE and token is removed.
  //   - Whenever you take an isolated source of UNDEFENDABLE damage: +2 damage (token stays).
  // Invisibilité (on defender): you may defend against an undefendable attack (spend token to allow defense).
  function applyDamageWithStatuses(baseDamage, {undefendable, sourceName}){
    let dmg = baseDamage;
    let isUndef = !!undefendable;

    // If you are webbed and this is a normal attack -> convert to undefendable and remove webbed
    if(state.you.webbed > 0 && !isUndef && dmg > 0){
      isUndef = true;
      state.you.webbed = 0;
      addLog("you", "Entoilé: l’attaque normale devient IMParable et Entoilé est retiré.");
    }

    // If attack is undefendable and you are webbed: +2 (token stays)
    if(state.you.webbed > 0 && isUndef && dmg > 0){
      dmg += 2;
      addLog("you", "Entoilé: +2 dégâts car source de dégâts IMParables.");
    }

    // Defense handling
    let reduction = 0;
    if(dmg > 0){
      if(isUndef){
        // If you have invisibility token, you can spend it to defend
        if(state.you.invis > 0){
          const use = confirm("Attaque IMParable. Utiliser 1x Invisibilité pour pouvoir défendre ?");
          if(use){
            state.you.invis = Math.max(0, state.you.invis-1);
            const r = prompt("Entre la réduction de défense (0 si aucune).", "0");
            reduction = Math.max(0, Number(r||0));
            addLog("you", `Invisibilité dépensée → Défense appliquée (-${reduction}).`);
          } else {
            addLog("you", "Attaque IMParable → pas de défense.");
          }
        } else {
          addLog("you", "Attaque IMParable → pas de défense.");
        }
      } else {
        const r = prompt(`Attaque défendable: "${sourceName}". Entre la réduction de défense (0 si aucune).`, "0");
        reduction = Math.max(0, Number(r||0));
        if(reduction>0) addLog("you", `Défense (-${reduction}).`);
      }
    }

    dmg = Math.max(0, dmg - reduction);
    state.you.hp = clamp(state.you.hp - dmg, 0, state.you.hpMax);

    addLog("bot", `${sourceName} → ${dmg} dégâts ${isUndef ? "(IMParables)" : ""}.`);
  }

  // === Execute one offensive roll phase for bot ===
  function botOffensiveRollPhase(label){
    // reset dice
    state.botDice.forEach(d => { d.locked=false; d.value=1; });

    let chosen = null;

    for(let roll=1; roll<=3; roll++){
      rollUnlockedDice();

      const vals = diceValues();
      const faces = diceFaces();

      renderDice();
      addLog("bot", `${label} — Lancer ${roll}/3: [${vals.join(", ")}] / ${faces.join(" ")}`);

      const bestNow = bestPlayableAttack(vals, faces);
      if(bestNow){
        // stop early if strong enough
        const thresh = (roll===1 ? 8 : roll===2 ? 6 : 0);
        const est = bestNow.effects?.roll2DamageSum ? 7 : (bestNow.damage||0);
        if(est >= thresh){
          chosen = bestNow;
          addLog("bot", `Je garde: "${bestNow.name}".`);
          break;
        }
      }

      if(roll < 3){
        const target = chooseTarget(vals, faces);
        lockForTarget(target, vals, faces);
        renderDice();
        if(target) addLog("bot", `Objectif: ${target.name}.`);
      } else {
        chosen = bestNow || { name:"Attaque basique", req:{}, type:"attack", damage:2, undefendable:false, effects:{} };
        if(!bestNow) addLog("bot", "Aucun combo: attaque basique (2).");
      }
    }

    return chosen;
  }

  // === Resolve chosen ability ===
  function resolveAbility(chosen){
    if(!chosen) return;

    // Effects first (gain tokens)
    if(chosen.effects?.gainInvis){
      state.bot.invis = 1;
      addLog("bot", "Gagne Invisibilité (max 1).");
    }
    if(chosen.effects?.gainCombo){
      state.bot.combo = 1;
      addLog("bot", "Gagne Combo (max 1).");
    }
    if(chosen.effects?.inflictWebbed){
      state.you.webbed = 1;
      addLog("bot", "Inflige Entoilé (max 1).");
    }

    // Special: gainComboIf4Same (Allonge II rule on card)
    if(chosen.effects?.gainComboIf4Same){
      const ms = maxSameNumber(diceValues());
      if(ms >= 4){
        state.bot.combo = 1;
        addLog("bot", "Allonge II: 4 chiffres identiques → gagne Combo.");
      }
    }

    // Damage logic
    let dmg = chosen.damage || 0;

    // Special: roll2DamageSum
    if(chosen.effects?.roll2DamageSum){
      const d1 = 1 + Math.floor(Math.random()*6);
      const d2 = 1 + Math.floor(Math.random()*6);
      dmg = d1 + d2;
      addLog("bot", `Réflexes d’Araignée: 2 dés bonus = ${d1}+${d2} → ${dmg} dégâts.`);
      if(typeof chosen.effects.gainComboIfSumLE === "number" && dmg <= chosen.effects.gainComboIfSumLE){
        state.bot.combo = 1;
        addLog("bot", `Réflexes d’Araignée: total ≤ ${chosen.effects.gainComboIfSumLE} → gagne Combo.`);
      }
    }

    if(chosen.effects?.draw1){
      addLog("bot", "Piège II (Grande suite): Piochez 1 (info seulement).");
    }

    // Apply damage with statuses
    if(dmg > 0){
      applyDamageWithStatuses(dmg, { undefendable: !!chosen.undefendable, sourceName: chosen.name });
    } else {
      addLog("bot", `Résolution: "${chosen.name}" (pas de dégâts).`);
    }
  }

  // === Bot turn ===
  function botTurn(){
    if(state.active !== "bot"){
      addLog("bot", "Impossible : ce n'est pas le tour du bot.");
      return;
    }
    if(state.you.hp <= 0 || state.bot.hp <= 0) return;

    // If bot attacks list empty => can't play
    if(!state.attacks || state.attacks.length === 0){
      addLog("bot", "Ce bot n’a pas d’attaques configurées. (Sélectionne Miles ou colle les attaques dans le JSON.)");
      return;
    }

    // Income (simple)
    state.bot.cp += 1;
    addLog("bot", `Revenu: +1 PC (→ ${state.bot.cp}).`);

    // Reset combo-use for this turn (Combo rule: limit 1 per turn)
    let comboUsedThisTurn = false;

    // Phase 1
    const chosen1 = botOffensiveRollPhase("Phase offensive");
    resolveAbility(chosen1);

    renderAll();

    if(state.you.hp <= 0) { addLog("bot", "Tu es K.O. (PV à 0)."); renderAll(); return; }

    // Combo extra phase (if bot has combo and hasn't used this turn)
    if(state.bot.combo > 0 && !comboUsedThisTurn){
      const use = confirm("Le bot a Combo. L’utiliser pour rejouer une phase offensive supplémentaire ?");
      if(use){
        state.bot.combo = 0;
        comboUsedThisTurn = true;
        addLog("bot", "Combo dépensé → phase offensive supplémentaire !");
        const chosen2 = botOffensiveRollPhase("Combo: phase offensive +1");
        resolveAbility(chosen2);
      }
    }

    // End turn
    state.active = "you";
    state.turn += 1;
    addLog("you", `À toi. Tour ${state.turn}.`);
    renderAll();

    if(state.you.hp <= 0) addLog("bot", "Tu es K.O. (PV à 0).");
    if(state.bot.hp <= 0) addLog("you", "Le bot est K.O. (PV à 0).");
  }

  // === Render ===
  function renderTop(){
    $("turnPill").textContent = state.turn;
    $("activePill").textContent = state.active === "you" ? "Toi" : "Bot";
  }

  function renderKPIs(){
    $("youHp").textContent = state.you.hp;
    $("youCp").textContent = state.you.cp;
    $("botHp").textContent = state.bot.hp;
    $("botCp").textContent = state.bot.cp;

    $("youWebbed").textContent = state.you.webbed;
    $("youInvis").textContent = state.you.invis;

    $("botCombo").textContent = state.bot.combo;
    $("botInvis").textContent = state.bot.invis;
  }

  function renderDice(){
    const host = $("diceRow");
    host.innerHTML = "";
    state.botDice.forEach((d) => {
      const el = document.createElement("div");
      el.className = "die" + (d.locked ? " locked" : "");
      el.innerHTML = `<div>${faceOf(d.value)}</div><div class="n">${d.value}</div><div class="mini">${d.locked ? "LOCK" : ""}</div>`;
      el.title = "Debug: clic pour lock/unlock.";
      el.addEventListener("click", () => {
        d.locked = !d.locked;
        renderDice();
      });
      host.appendChild(el);
    });
  }

  function renderLog(){
    const host = $("log");
    host.innerHTML = "";
    state.log.forEach(item => {
      const el = document.createElement("div");
      el.className = "logItem";
      const tagClass = item.who === "bot" ? "bot" : "you";
      el.innerHTML = `<time>${escapeHtml(item.t)}</time><span class="tag ${tagClass}">${escapeHtml(item.who)}</span>${escapeHtml(item.text)}`;
      host.appendChild(el);
    });
    host.scrollTop = host.scrollHeight;
  }

  function renderAll(){
    renderTop();
    renderKPIs();
    renderDice();
    renderLog();
  }

  // === Bot selection ===
  function loadBot(key){
    state.botKey = key;
    const bot = BOTS[key];
    state.attacks = structuredClone(bot.attacks || []);
    addLog("you", `Bot sélectionné: ${bot.name}.`);
    $("attacksJson").value = JSON.stringify(state.attacks, null, 2);
    renderAll();
  }

  // === UI wiring ===
  document.querySelectorAll("button[data-who]").forEach(btn => {
    btn.addEventListener("click", () => {
      const who = btn.dataset.who;
      const what = btn.dataset.what;
      const d = Number(btn.dataset.d);

      if(what === "hp"){
        state[who].hp = clamp(state[who].hp + d, 0, state[who].hpMax);
        addLog(who === "bot" ? "bot" : "you", `${who.toUpperCase()} PV ${d>0?"+":""}${d} → ${state[who].hp}`);
      } else {
        state[who].cp = Math.max(0, state[who].cp + d);
        addLog(who === "bot" ? "bot" : "you", `${who.toUpperCase()} PC ${d>0?"+":""}${d} → ${state[who].cp}`);
      }
      renderKPIs();
    });
  });

  $("endYourTurnBtn").addEventListener("click", () => {
    if(state.active !== "you"){ addLog("you","Ce n'est pas ton tour."); return; }
    state.active = "bot";
    addLog("you","Fin de mon tour → Bot.");
    renderTop();
  });

  $("botTurnBtn").addEventListener("click", botTurn);

  $("resetBtn").addEventListener("click", () => {
    if(!confirm("Reset (recharger la page) ?")) return;
    location.reload();
  });

  $("clearLogBtn").addEventListener("click", () => {
    state.log = [];
    renderLog();
  });

  $("botSelect").addEventListener("change", (e) => {
    loadBot(e.target.value);
  });

  // Status buttons
  $("youAddWebbed").addEventListener("click", () => { state.you.webbed = 1; addLog("you","+ Entoilé (max 1)."); renderAll(); });
  $("youRemWebbed").addEventListener("click", () => { state.you.webbed = 0; addLog("you","- Entoilé."); renderAll(); });
  $("youAddInvis").addEventListener("click", () => { state.you.invis = 1; addLog("you","+ Invisibilité (max 1)."); renderAll(); });
  $("youRemInvis").addEventListener("click", () => { state.you.invis = 0; addLog("you","- Invisibilité."); renderAll(); });

  $("botAddCombo").addEventListener("click", () => { state.bot.combo = 1; addLog("bot","+ Combo (max 1)."); renderAll(); });
  $("botRemCombo").addEventListener("click", () => { state.bot.combo = 0; addLog("bot","- Combo."); renderAll(); });
  $("botAddInvis").addEventListener("click", () => { state.bot.invis = 1; addLog("bot","+ Invisibilité (max 1)."); renderAll(); });
  $("botRemInvis").addEventListener("click", () => { state.bot.invis = 0; addLog("bot","- Invisibilité."); renderAll(); });

  // JSON editor
  $("loadFromBotBtn").addEventListener("click", () => {
    $("attacksJson").value = JSON.stringify(state.attacks, null, 2);
    addLog("you","JSON chargé depuis le bot courant.");
  });

  $("applyAttacksBtn").addEventListener("click", () => {
    try{
      const parsed = JSON.parse($("attacksJson").value);
      if(!Array.isArray(parsed)) throw new Error("attacks must be array");
      // minimal validation
      for(const a of parsed){
        if(!a.name) throw new Error("missing name");
        if(!a.req) a.req = {};
        if(!a.effects) a.effects = {};
        a.damage = Number(a.damage||0);
        a.undefendable = !!a.undefendable;
      }
      state.attacks = parsed;
      // also store into bot DB for this session
      BOTS[state.botKey].attacks = structuredClone(parsed);
      addLog("you","Attaques appliquées au bot courant.");
      renderAll();
    }catch(e){
      addLog("you", "JSON invalide (attacks).");
    }
  });

  // Init
  $("attacksJson").value = JSON.stringify(state.attacks, null, 2);
  addLog("you", "Prêt. Joue ton tour, puis “Fin de ton tour → Bot”, puis “Jouer le tour du Bot”.");
  renderAll();
})();
</script>
</body>
</html>
